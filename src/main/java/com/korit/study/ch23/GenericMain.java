package com.korit.study.ch23;

public class GenericMain {

    public static void main(String[] args) {
        // 문자열, 정수, 자기 자신 + null, 객체 담기 또한 가능하다. 최상위 클래스 Object 를 걸어줬으니까.
        NonGeneric a = new NonGeneric("문자열 데이터");
        NonGeneric b = new NonGeneric(10);
        NonGeneric c = new NonGeneric(new NonGeneric(null));
        NonGeneric d = new NonGeneric(a);

        NonGeneric[] arr = {a, b, c, d};
        for (NonGeneric n : arr) {
            System.out.println(n.getData().getClass()); // 원래 원형으로 돌리는 방법
            if (n.getData() instanceof String data) { // n.getData 의 원래 원형이 문자열이면
                // String data = (String) n.getData(); <= 옛날 방식으로 다운캐스팅을 쓰면 이런 식으로...
                System.out.println(data); // String 클래스가 가진 타입을 쓸 수 있게 됨
                // 이 if 의 data 는 지역변수이기 때문에 빠져나오지 않음.
                // 결론은 분기가 나뉜다는 것. 위는 String, 아래는 Non data 라서 각 지역 안에서 data 를 쓸 수 있고 겹쳐도 문제가 안 생기는 이유.
                // 지역이 다르고 서로 다르기 때문임.
            } else if (n.getData() instanceof NonGeneric data) {
                System.out.println(data.getData());
            }
        }

        Generic<String, Integer> e = new Generic<String, Integer>("문자열 데이터", "문자열 데이터2", 3.14, 10); // T 는 스트링 T2 는 인티저
        Generic<String, Integer> f = new Generic<>("문자열 데이터", "문자열 데이터2", 3.14, 10);
        // 변수는 값을 대입해줘야 함. 그러므로 제네릭 앞 꺽쇠 안에 바꾸고 싶은 타입을 꼭 기재해줘야 한다.
        // 적지 않는다면 그저 T 타입의 오브젝트를 쓰겠다는 것과 동일.

        Object[] arr2 = new Object[1]; // 이 배열 안에는 오브젝트 객체만 들어가야 함.
        // 이걸 자료형 제네릭처럼 쓸 순 없을까? 여기서 중요한 건 일반 자료형은 제네릭으로 쓸 수가 없다.
        // 그럼 배열은 참조일까 일반일까? 배열은 일반 자료형이므로 제네릭 사용 불가.

    }
}

/**
 * Object 를 쓰면 다른 자료형을 안 써도 되는데 왜 굳이 int, String 같은 각 자료형을 쓰는 걸까?
 * Object 를 쓴다는 건 모두 업캐스팅이 되기 때문에 자식들만 쓸 수 있는 기능을 쓸 수가 없음.
 * 결국은 원래의 원형을 알 수가 없고 다운캐스팅 시켜줘야 값의 원래 역할을 할 수 있게끔 만들어줘야 함.
 * 문자열, 객체, 숫자 등 오브젝트로 다 평등하게 보면 각자의 특성을 무시해버리기 때문에
 * 다운캐스팅 방법은 앞에 명시를 해주는 것.
 *
 * 만약에 배열에 넣었다? 나중에는 위처럼 직접 명시되어 있는 게 아니라 그저 배열에 a, b, c, d 로만
 * 기재가 되어 내가 알 수 없게 됨. 그때는 get class 를 사용해서
 *
 * 오브젝트는 최상위 클래스이고 뭐든 다 집어넣을 수 있다는 장점 하지만
 * 데이터의 원형대로 쓰고 싶으면 오브젝트를 다운캐스팅 시켜야 한다는 불편함
 *
 * - - - - -
 *
 * 26 코드를 잘 보면 생략할 수 있게 회색빛으로 색이 바뀌어있음. 앞에 기재가 되어 있기 때문에
 * 꺽쇠 자체를 지우는 건 안 되지만 안을 비울 수는 있음.
 * 또 Integer 를 사용하고 있는데 int 를 사용할 수 없음. 둘의 차이는 일반 자료형, 참조 자료형의 차이점이 있다.
 * 일반 자료형과 참조 자료형의 차이란?
 * int a = 10;
 * Integer a = 10; => new Integer(10);
 * 둘의 차이는 참조 자료형태로 바뀐다는 것. 즉 Integer 박스 안에 10 이라는 값을 넣었따. 포장했다고 보면 됨.
 * boxing, unboxing... Wrapper
 *
 * 우리가 쓰는 일반적인 정수, 실수, 문자, 문자열, 배열은 단순구조에 들어감.
 * 참조 자료형도 단순 구조, 일반 자료형도 단순 구조에 들어감.
 *
 * 배열은 인덱스를 참조해서 타고 들어가고 앞에 new 를 붙이는데 왜 참조가 아닐까?
 * new 는 생성 때 쓰는 것. 객체 생성이 아니라... 힙, 동적 등 메모리에 할당할 때!! 사용됨.
 * 배열은 객체가 아니다. 그럼 참조 자료형이 아니다. 객체가 아니면 참조 자료형이라 할 수 없다.
 * 배열이라 하는 건 일반도 참조도 배열로 만들 수 있고 어떠한 일반, 참조 자료형이라 딱 잘라 말할 수가 없다.
 * 배열이라 하는 개념은 User 는 우리가 직접 만드는 자료형. 이는 사용자 정의 자료형인데
 * 배열이라 하는 자료형은 커스텀한 게 맞을까? User 는 클래스를 정의해서 만든 거고 배열은 이미 존재하던 자료형이라
 * 사용자가 정의한 게 아니다. 일반 자료형이 있고 배열 자료형이 따로 있는 거임.
 * 어떤 걸 배열로 할 건지만 우리가 정하는 거고 자료형의 개념 자체는 이미 있던 것.
 *
 * 배열은 한 메모리를 통째로 다 가지고 메모리가 순서대로 이어져있음 끊어져있지 않고 무조건 이어져 있어서 이를 배열 자료 구조라고 함
 * 선형 구조라는 것은 메모리가 막 다른 곳에 있고 배열처럼 연결되어 있지 않은데 서로 각각의 위치 주소를
 * 가지고 있다는 것. 서로간의 나 다음, 이전 주소를 가지고 있어서 타고 타고 타고 들어가는 걸 선형 구조라고 함.
 * 메모리가 흩어져 있는데 이게 뭐가 좋으냐?
 * 배열은 5만큼의 공간을 한번에 만드는데 혹시나 그런 공간이 없다면 만들 수 없는데 선형 구조는 빈틈에다가 
 * 쑤셔넣을 수 있다. 따로 떨어져있지만! 배열처럼 이어진 것처럼 쓸 수 있다.
 *
 * 비선형구조는 한 녀석을 타고 갔더니 하나의 안에 여러개가 연결되어 있는 구조. 한줄로 가는 게 아니라 여러 갈래로
 * 쭉 나눠져서 꾸려진 형태가 원이 될 수도 있다.트리는 나무처럼 위에서 아래로 노드들이 뿌려지고 뿌려지는 형태. 젤
 * 상위의 것을 올렸더니 트리 형태. 그래프 또한 있다.
 *
 * 파일구조는 저장하고 불러올 수 있는 구조가 있음. 결국 파일의 구조가 트리 형태처럼 되어있는 경우가 많음.
 * 예를 들면 우리 C 드라이브에 여러 파일이 있고 타고 들어가게 되는 거.
 *
 *
 * 결론은 묶은 자료형이 배열. 얘는 일반도 참조도 아닌 그저 배열이라 부름.
 *
 *
 *
 */